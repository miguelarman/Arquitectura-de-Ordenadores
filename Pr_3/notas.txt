Ejercicio 0
Ejercicio 1

"Para obtener los datos, ejecutamos primero slow para todos los tama˜nos indicados y guardamos los datos obtenidos en un array, de forma que el dato de la matriz de tama˜no m´as peque˜no est´a en la primera posici´on del array y la m´as grande en la ´ultima posici´on" Poner cursiva en slow y fast

"Adem´as este programa elimina las comas de los n´umeros (es decir, convierte 2,043 en 2043), lo cual..." Explicar que no quita las comas de los decimales, sino que quita las de los millares porque se ponen solas

"En la gr´afica observamos que el tiempo de slow aumenta notablemente m´as que el tiempo de fast con el aumento de la matriz." cursiva

"Por ello, a tama˜nos peque˜nos hay tan pocos accesos a memoria que no se nota apenas una diferencia en cuanto a tiempo. " No es que no haya accesos a memoria. Literlamente, se leen los mismos datos. Lo que cambia es el orden y los fallos de caché que por ello dan.

"Como ya hemos indicado, se guardan por filas en memoria y por esta raz´on es menos costoso acceder por filas que por columnas." Añadir "Por ello, cuando cargamos en caché un dato que no estaba, como se carga un bloque entero, y no solo un dato, se cargan los siguientes valores, que no darían fallo de memoria al ser leidos"


Ejercicio 2

" Esto se debe que al tener un mayor tama˜no se puede almacenar un mayor n´umero de datos y por tanto se fallar´a un menor n´umero de veces." Decir que al poder almacenar más datos, es más probable que el dato al que accedemos esé cargado en la caché, por lo que no será necesario cargarlo de memoria., que es una operación costosa en cuanto a tiempo

"Es algo obvio pues la forma de acceder a las matrices en memoria no afecta a como se escribe en la cach´e." Para la escritura, se accede las mismas veces, puesto que cada vez que actualizamos la suma total, necesitamos ese dato en caché. Por lo tanto, como con cada fila/columna se debe cargar el dato en caché, este se carga las mismas veces independientemente.

"Sin embargo, para el caso de lectura si que hay un cambio de tendencia.(rellenar
mas npi)". Esto se debe a lo que hemos explicado en el ejercicio anterior, ya que para leer una fila de datos se necesitan menos cargas a caché, porque cada una carga algún dato contiguo al cargar un bloque de memoria, que se lee entero o casi. Por el contrario, para leer por columnas, para leer cada dato se carga un bloque entero.



Ejercicio 3

¿Se observan cambios de tendencia al variar los tama˜nos de las matrices? ¿A
qu´e se deben los efectos observados?

Se puede observar que los tiempos de ejecución sifuen una tendencia lineal en ambos cálculos, de forma que la diferencia entre ambos crece de forma lineal. Por otra parte, en los falls de caché la relación entre el acceso en el cáclulo con la traspuesta son tan inferiores, que para la gráfica son demasiado pequeños.
A priori, podríamos pensar que los accesos a memoria, y por lo tanto los tiempos de ejecución, deberían variar con el tamaño de la matriz de forma cuadrática, puesto que ambas dimensiones varían. Sin embargo, en la gráfica de los tiempos se puede ver que esto no es correcto. Estos se puede deber a varias cosas:
- Los tiempos de ejecución no son una medida fija, puesto que dependen del ordenador y los otros proseos
- La ejecución con la traspuesta implica también el coste de trasponer la matriz, que se añade al tiempo de cálculo
- Puede que la variación de tamaño de matriz no sea lo suficientemente grande para apreciar el comportamiento cuaadrático, y lo que apreciamos es una curva muy amplificada que parece recta. Esto se puede deber a que como nos indicó el profesor, reducimos el amaño de las matrices, y la variación de los mismos, ppuesto que el tiempo de ejeución si no se disparaba.

Ejercicio 4

Para este ejercicio, lo que hicimos fue ejecutar los mismos cálculos del ejercicio anterior, variando el tamaño de cahé (1 KB, 2 KB, 4 KB y 8 KB).

Nos hubiera gustado haber podido experimentar con más parámetros (asociatividad o tamaño de palabra), pero el tiempo de ejecución fue muy largo (realizamos varias mediciones para reducir errores, con tamaños de matriz vareiable y con distintos tamaños de caché) lo cual son muchos bucles:

$ time ./ejercicio4.sh

real	546m7,944s
user	545m4,852s
sys	1m31,440s

Como se puede ver, este programa tardó casi 9 horas en ejecutarse.

Lo que hemos podido comprobar es que cuanto mayor fuera la caché, más se reducían los fallos de caché, casi llegandose a reducirse a la mitad comparando 1 KB con 8 KB. Esto quiere decir que ampliar la caché cada vez más no es una estrategia óptima, puesto que multiplicando por 8 el tamaño de caché, solo se dividen por 2 los fallos de memoria, sin tener en cuenta los problemas reales que conlleva esto de aumento de precio y tamaño de la caché. Además, si comparamos el tiempo de ejecución, el cambio no es nada relevante, puesto que se ve que empíricamente es mejor estrategia usar la estrategia de trasponer, que multiplicar por 8 el tamaño de la caché.

Desde luego, aunque para esta práctica no hayamos podido comparar todos los aspectos posibles, sin duda en nuestro tiempo libre intentaremos realizar una comparación de esto para ver cómo influyen en un problema real estos cambios, puesto que sabemos que es un problema real, con el que quizás nos encontremos en nuestra vida laboral.
